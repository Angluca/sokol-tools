/*
    Generator base class implementation.
*/
#include "generator.h"
#include "util.h"

using namespace shdc::gen::util;
using namespace shdc::refl;

namespace shdc::gen {

ErrMsg Generator::generate(const GenInput& gen) {
    ErrMsg err;
    err = begin(gen);
    if (err.valid()) {
        return err;
    }
    gen_prolog(gen);
    // FIXME: instead of the first valid Slang, the GenInput struct should
    // have a 'common reflection' object
    const Slang::Enum slang = Slang::first_valid(gen.args.slang);
    gen_header(gen, slang);
    gen_vertex_attrs(gen, slang);
    gen_bind_slots(gen);
    gen_uniform_blocks(gen);
    gen_epilog(gen);
    err = end(gen);
    return err;
}

// default behaviour of begin is to clear the generated content string, and check for error in GenInput
ErrMsg Generator::begin(const GenInput& gen) {
    content.clear();
    return check_errors(gen);
}

// epilog is any code which must go before documentation header
void Generator::gen_prolog(const GenInput& gen) {
    // empty
}

// create a default comment header
void Generator::gen_header(const GenInput& gen, Slang::Enum slang) {
    l("{}\n", comment_block_start());
    cbl("#version:{} (machine generated, don't edit!)\n\n", gen.args.gen_version);
    cbl("Generated by sokol-shdc (https://github.com/floooh/sokol-tools)\n\n");
    cbl("Cmdline:\n");
    cbl("    {}\n\n", gen.args.cmdline);

    // FIXME: instead of the first valid slang, GenInput should instead give us pre-processed and merged reflection info!
    cbl("Overview:\n");
    for (const auto& item: gen.inp.programs) {
        const Program& prog = item.second;
        const SpirvcrossSource* vs_src = find_spirvcross_source_by_shader_name(prog.vs_name, gen.inp, gen.spirvcross[slang]);
        const SpirvcrossSource* fs_src = find_spirvcross_source_by_shader_name(prog.fs_name, gen.inp, gen.spirvcross[slang]);
        assert(vs_src && fs_src);
        cbl("    Shader program: '{}':\n", prog.name);
        cbl("        Get shader desc: {}", get_shader_desc_help(mod_prefix(gen.inp), prog.name));
        gen_vertex_shader_info(gen, prog, *vs_src);
        gen_fragment_shader_info(gen, prog, *fs_src);
    }
    l("{}\n", comment_block_end());
    l("\n");
}

void Generator::gen_vertex_shader_info(const GenInput& gen, const Program& prog, const SpirvcrossSource& src) {
    cbl("        Vertex shader: {}\n", prog.vs_name);
    cbl("            Attributes:\n");
    const Snippet& vs_snippet = gen.inp.snippets[src.snippet_index];
    for (const VertexAttr& attr: src.refl.inputs) {
        if (attr.slot >= 0) {
            cbl("                {} => {}\n", to_vertex_attr_name(mod_prefix(gen.inp), vs_snippet.name, attr), attr.slot);
        }
    }
    gen_bindings_info(gen, src.refl.bindings);
}

void Generator::gen_fragment_shader_info(const GenInput& gen, const Program& prog, const SpirvcrossSource& src) {
    cbl("        Fragment shader: {}\n", prog.fs_name);
    gen_bindings_info(gen, src.refl.bindings);
}

void Generator::gen_bindings_info(const GenInput& gen, const Bindings& bindings) {
    for (const UniformBlock& ub: bindings.uniform_blocks) {
        cbl("            Uniform block '{}':\n", ub.struct_name);
        cbl("                {} struct: {}\n", lang_name(), to_struct_name(mod_prefix(gen.inp), ub.struct_name));
        cbl("                Bind slot: {} => {}\n", to_uniform_block_bind_slot_name(mod_prefix(gen.inp), ub), ub.slot);
    }
    for (const Image& img: bindings.images) {
        cbl("            Image '{}':\n", img.name);
        cbl("                Image type: {}\n", to_image_type(img.type));
        cbl("                Sample type: {}\n", to_image_sample_type(img.sample_type));
        cbl("                Multisampled: {}\n", img.multisampled);
        cbl("                Bind slot: {} => {}\n", to_image_bind_slot_name(mod_prefix(gen.inp), img), img.slot);
    }
    for (const Sampler& smp: bindings.samplers) {
        cbl("            Sampler '{}':\n", smp.name);
        cbl("                Type: {}\n", to_sampler_type(smp.type));
        cbl("                Bind slot: {} => {}\n", to_sampler_bind_slot_name(mod_prefix(gen.inp), smp), smp.slot);
    }
    for (const ImageSampler& img_smp: bindings.image_samplers) {
        cbl("            Image Sampler Pair '{}':\n", img_smp.name);
        cbl("                Image: {}\n", img_smp.image_name);
        cbl("                Sampler: {}\n", img_smp.sampler_name);
    }
}

void Generator::gen_vertex_attrs(const GenInput& gen, Slang::Enum slang) {
    for (const SpirvcrossSource& src: gen.spirvcross[slang].sources) {
        if (src.refl.stage == ShaderStage::VS) {
            const Snippet& vs_snippet = gen.inp.snippets[src.snippet_index];
            for (const VertexAttr& attr: src.refl.inputs) {
                if (attr.slot >= 0) {
                    l("{}\n", to_vertex_attr_definition(mod_prefix(gen.inp), vs_snippet.name, attr));
                }
            }
        }
    }
    l("\n");
}

void Generator::gen_bind_slots(const GenInput& gen) {
    for (const UniformBlock& ub: gen.merged_bindings.uniform_blocks) {
        l("{}\n", to_uniform_block_bind_slot_definition(mod_prefix(gen.inp), ub));
    }
    l("\n");
    for (const Image& img: gen.merged_bindings.images) {
        l("{}\n", to_image_bind_slot_definition(mod_prefix(gen.inp), img));
    }
    l("\n");
    for (const Sampler& smp: gen.merged_bindings.samplers) {
        l("{}\n", to_sampler_bind_slot_definition(mod_prefix(gen.inp), smp));
    }
    l("\n");
}

void Generator::gen_uniform_blocks(const GenInput& gen) {
    // FIXME
}

void Generator::gen_epilog(const GenInput& gen) {
    // empty
}

// default behaviour of end() is to write the output file
ErrMsg Generator::end(const GenInput& gen) {
    FILE* f = fopen(gen.args.output.c_str(), "w");
    if (!f) {
        return ErrMsg::error(gen.inp.base_path, 0, fmt::format("failed to open output file '{}'", gen.args.output));
    }
    fwrite(content.c_str(), content.length(), 1, f);
    fclose(f);
    return ErrMsg();
}

// check that each input shader has a vs and fs source
ErrMsg Generator::check_errors(const GenInput& gen) {
    for (int i = 0; i < Slang::NUM; i++) {
        Slang::Enum slang = Slang::from_index(i);
        if (gen.args.slang & Slang::bit(slang)) {
            for (const auto& item: gen.inp.programs) {
                const Program& prog = item.second;
                int vs_snippet_index = gen.inp.snippet_map.at(prog.vs_name);
                int fs_snippet_index = gen.inp.snippet_map.at(prog.fs_name);
                int vs_src_index = gen.spirvcross[i].find_source_by_snippet_index(vs_snippet_index);
                int fs_src_index = gen.spirvcross[i].find_source_by_snippet_index(fs_snippet_index);
                if (vs_src_index < 0) {
                    return gen.inp.error(gen.inp.snippets[vs_snippet_index].lines[0],
                        fmt::format("no generated '{}' source for vertex shader '{}' in program '{}'",
                        Slang::to_str(slang), prog.vs_name, prog.name));
                }
                if (fs_src_index < 0) {
                    return gen.inp.error(gen.inp.snippets[vs_snippet_index].lines[0],
                        fmt::format("no generated '{}' source for fragment shader '{}' in program '{}'",
                        Slang::to_str(slang), prog.fs_name, prog.name));
                }
            }
        }
    }
    // all ok
    return ErrMsg();
}

} // namespace
